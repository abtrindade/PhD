Here we describe the two tools created with the target to implement and validate the two scientific methodologies of the thesis.

%---------------------------------------
\section{Tools}
%---------------------------------------

During the Ph.D. process, the techniques from computer science proposed to tackle issues related to solar photovoltaic systems became algorithms and programs. Those programs became tools, and the tools were used during comparative with simulation tools in order to validate the techniques.

\textcolor{red}{the second part of this sentence is unclear...} In general, we pursuit to write code that could be verification tool independent, i.e., that can be used in any model checking tool without adaptation, since we aimed to evaluate different.

We wrote the tools in the C programming language, without the use of '\# include', or '\# define'. Based on the fact that there exists no use of compiler library, it was necessary to write some functions, which perform specific calculations according to the adopted mathematical models (e.g., logarithm of natural order and exponential).

%---------------------------------------
\subsection{Automated Verification Tool (PV System validation)}
\label{sec:automatedverification}
%---------------------------------------

We split the code into four blocks:

\begin{itemize}
\item \textbf{Block 1}: global variables declaration, with weather data from location (minimum and maximum solar irradiance and temperature, for 24-hour of the day) as array, requirements, and datasheet information from each equipment of the PV system that will be verified; 

\item \textbf{Block 2}: support functions (e.g., logarithm of natural order, exponential);

\item \textbf{Block 3}: PV system specific functions (charge battery, discharge battery, PV panel generation, sizing check);

\item \textbf{Block 4}: main code with charge, discharge battery control, based on PV generation from solar panels and the state of charge form batteries, committing to deliver the power and energy that the house demands, according with the restrictions form the sized system.
\end{itemize}

%---------------------------------------
\subsection{Automated Synthesis Tool (PV System Optimal Sizing)}
\label{sec:automatedsynthesis}
%---------------------------------------

We split the code into three blocks:

\begin{itemize}
\item \textbf{Block 1}: global variables declaration, with weather data from location, requirements, and datasheet information from each equipment of the PV system that will be verified; 

\item \textbf{Block 2}: support functions (start value with the lowest cost for the list of equipment, synthesis phase function to obtain feasible technical solutions with model checking);

\item \textbf{Block 3}: main code with the iterative control of the verify phase.
\end{itemize}


%---------------------------------------
\section{How to use it}
%---------------------------------------

The only block that demands user intervention to input data is block 1 of both tools \textcolor{red}{where can I see block 1? which tools?}. If it is aimed to change the mathematical model adopted, so coding must be done in block 3 of the automated verification tool and block 2 of the automated synthesis tool.

Regarding the automated verification tool, it is necessary to input the following data (editing and modifying the code):

\begin{itemize}
\item Minimum and maximum solar irradiance (average value for the 24-hour of the day) from location;
\item Minimum and maximum temperature (average for every month of the year);
\item Local insolation (average number of sun hours by day at the location);
\item Number of solar panels in series;
\item Number of solar panels in parallel;
\item Number of series-connected cells from each solar panel;
\item Nominal Operating Cell Temperature;
\item Reference solar irradiance;
\item Reference temperature;
\item Short-circuit current temperature coefficient;
\item Open-circuit voltage temperature coefficient;
\item Reference short-circuit current;
\item Reference open-circuit voltage;
\item Reference maximum current, voltage, and power;
\item Minimum MPPT voltage;
\item Operation current;
\item Solar panel efficiency;
\item Panel area in square meters;
\item DC-bus voltage;
\item Individual battery voltage;
\item Battery bank capacity;
\item State of charge limit;
\item Number of batteries in series;
\item Number of batteries in parallel;
\item Autonomy of the batteries;
\item Efficiency from batteries;
\item Float, absorption, and bulk battery voltages;
\item Charge controller efficiency;
\item Charge controller current;
\item Charge controller maximum voltage;
\item Inverter output voltage;
\item Inverter AC reference power;
\item Inverter maximum (surge) AC power reference;
\item AC voltage (outlet standard);
\item Power demand from the house;
\item Surge demand from the house;
\item Energy consumption from the house.
\end{itemize}

Moreover, regarding the automated synthesis tool, it is necessary to add the following data (editing and modifying the code):

\begin{itemize}
\item Minimum and maximum solar irradiance (average value for the 24-hour of the day) from location;
\item Minimum and maximum temperature (average for every month of the year);
\item Local insolation (average number of sun hours by day at the location);
\item DC-bus voltage;
\item Autonomy of the batteries;
\item State of charge limit;
\item Individual battery voltage;
\item Reference solar irradiance;
\item Reference temperature;
\item For every item of solar PV panel list, as a matrix (area, efficiency, number of series-connected cells, Nominal Operating Cell Temperature, short-circuit current temperature coefficient, open-circuit voltage temperature coefficient, reference short-circuit current, reference open-circuit voltage, reference maximum power, reference maximum current, reference maximum voltage, maximum voltage on NOCT, cost in US dollars);
\item For every item of batteries list, as a matrix (efficiency, voltage, capacity $C_{20}$), bulk voltage, float voltage, cost in US dollars);
\item For every item of charge controller list, as a matrix (efficiency, nominal current, voltage output, minimum MPPT voltage, maximum current, cost in US dollars);
\item For every item of inverter list, as a matrix (efficiency, input DC voltage, output AC voltage, reference AC power, reference maximum AC power, cost in US dollars);
\item AC voltage (outlet standard);
\item Power demand from the house;
\item Surge demand from the house;
\item Energy consumption from the house.
\end{itemize}

%---------------------------------------
\subsection{Automated Verification with Incremental ESBMC}
%---------------------------------------

Here we describe precisely how to use the code explained in the previous section (\ref{sec:automatedverification}) using the incremental ESBMC with the Z3 SMT solver that presented the better performance during the comparative than other verifiers. However, in \ref{sec:setup} it was showed how to use the code with other verifiers.

ESBMC can be downloaded from its GitHub in \url{https://github.com/esbmc/esbmc}. Installation commands can be found in \url{https://ssvlab.github.io/esbmc/documentation.html}. There is just the Linux version of the verifier.

\bigskip
\fbox{\parbox{\textwidth}{Command-line: \$ esbmc filename.c -\phantom{}-no-bounds-check -\phantom{}-no-pointer-check -\phantom{}-unwind 100 -\phantom{}-smt-during-symex -\phantom{}-smt-symex-guard -\phantom{}-z3.}}
\bigskip

Where:
\begin{itemize}
\item -no-bounds-check: says to the verifier to not perform array bound check (the aim is not to check array bound violation);
\item -\phantom{}-no-pointer-check: says to the verifier to not check if there is pointer violation;
\item -\phantom{}-unwind 100: it limits the bound of search (100 in this case);
\item -\phantom{}-smt-during-symex: enable incremental SMT solving;
\item -\phantom{}-smt-symex-guard: call the solver during symbolic execution;
\item -\phantom{}-z3: uses Z3 as solver.
\end{itemize}

Some results issued by the ESBMC verifier were shown in \ref{sec:ESBMCverification} when performing the case studies.

%---------------------------------------
\subsection{Automated Synthesis with CPAchecker}
%---------------------------------------

Here we describe precisely how to use the code explained in previous sections (\ref{sec:automatedsynthesis}) using CPAchecker with MathSAT solver, which presented better performance during the comparative than other verifiers. However, in \ref{sec:synthesissetup} it was showed how to use the code with other verifiers.

The CPAchecker can be downloaded from its web site in \url{https://cpachecker.sosy-lab.org/}. There are versions available to Linux and MS-Windows operational systems.

Install a Java Runtime Environment, which is at least Java 8 compatible (e.g., Oracle JRE, OpenJDK). Cf. the web site \url{http://java.oracle.com/}.

\bigskip
\fbox{\parbox{\textwidth}{The command-line in Linux is: \$ scripts/cpa.sh -heap 64000m -config config/bmc-incremental.properties -spec config/specification/sv-comp-reachability.spc filename.c.}} 
\bigskip

Note that the default heap size is 1200m (or 1.2 GB of RAM). However, it is indicated to specify a significant value with '-heap' if you have more RAM available. In our case, we adjusted the heap to 64000m (64 GB). 

Another important issue is the time-out of the execution process: the parameter 'limits.time.cpu' at the file 'resource-limits.properties' in folder 'config/includes' must be edited according to the desired value. In our case, 'limits.time.cpu = 14400s', i.e., 14400 seconds or 240 minutes or 4 hours.

Some results, reports, and graphics, issued by the CPAchecker verifier were depicted in \ref{sec:synthesisresults}.

