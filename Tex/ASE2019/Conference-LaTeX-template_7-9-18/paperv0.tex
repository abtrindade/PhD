\documentclass[10pt,conference]{IEEEtran}
% \documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\bibliographystyle{IEEEtran}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithm,algorithmic}
\usepackage{graphicx}
\usepackage{makecell}
\usepackage{textcomp}
\usepackage{xcolor}
\def \BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
    
 \renewcommand{\baselinestretch}{0.96}
    
\begin{document}

\title{Synthesizing Optimal Sizing of Stand-alone Solar Photovoltaic Systems\\
% \thanks{Identify applicable funding agency here. If none, delete this.}
}

\author{\IEEEauthorblockN{Alessandro Trindade}
\IEEEauthorblockA{\textit{Electricity Department} \\
\textit{Federal University of Amazonas}\\
Manaus, Brazil \\
alessandrotrindade@ufam.edu.br}
\and
\IEEEauthorblockN{Lucas Cordeiro}
\IEEEauthorblockA{\textit{School of Computer Science} \\
\textit{University of Manchester}\\
Manchester, England \\
lucas.cordeiro@manchester.ac.uk }
}

\maketitle

\begin{abstract}
Currently, there exist various state-of-the-art tools to design PV but they are mainly based on simulations, which do not cover all aspects of the design-space. 
We present a sound and automated approach to synthesize optimal sizing of stand-alone solar photovoltaic (PV) systems.
The application of automated formal verification to synthesize PV systems is a very recent subject with only a few initiatives. 
Here we develop and evaluate an automated formal synthesis approach based on program synthesis and report preliminary results 
using three state-of-art software verifiers with the goal of optimizing the sizing of a PV system. 
Commercial equipment data is provided to our synthesis engine and the candidate solution is derived 
from financial analysis of the obtained sizing. Our proposed synthesis method is novel and 
unprecedented to streamline the design of PV systems. 
Experimental results show that our synthesis method, based on software model checking as our verification engine, 
is able to synthesize, in an acceptable run-time, the optimal PV system sizing of two different case studies.
\end{abstract}

%\begin{IEEEkeywords}
%automated verification, model checking, program synthesis, electrical systems, and solar photovoltaic systems.
%\end{IEEEkeywords}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{INTRODUCTION}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Cyber-Physical Systems  (CPS) are engineered systems, which are built from, and depend upon, 
the seamless integration of computational  and  physical  components~\cite{NSF2015}. 
During operation, such components must frequently adapt to the executing environment changes 
faced at run-time (dynamics of the physical processes) and must be able to continue to behave 
in a controlled and safe way, thus posing novel technical challenges for the software engineering of services and applications for CPS~\cite{Metzger2014}. %Important quality aspects for CPS include scalability, e.g., ensuring that CPS applications can scale to urban-wide deployment environments [Nessi].
Software pervasiveness in every context of life also places new challenges. 
In particular, highly dynamic environments, rapidly changing requirements, 
unpredictable and uncertain operating conditions demand new paradigms for software design~\cite{Filieri2015}.

While some research efforts do exist to enhance and optimize the software development processes for CPS, 
further investigation and discussion of better and more effective models are still needed in practice~\cite{Al-Jaroodi2016}. 
Among the opportunities for enhancements, there exists the need for developing new techniques and tools to support 
CPS requirements gathering and analysis with the goal of synthesizing correct-by-construction implementations of CPS. 
The developed techniques need to deal with predefined requirements enforced by the nature and inherited constraints 
of the target CPS. In addition, they should be able to provide verification and validation mechanisms for completeness, 
correctness, and consistency~\cite{Al-Jaroodi2016}. Uncertainty and variability, at the same time, can be dealt with formal verification~\cite{NESSI}. 
Energy production, distribution, and optimization are all CPS problems~\cite{UC}. 

Lack of access to clean and affordable energy is considered a core dimension of poverty~\cite{Hussein2012}. 
Progress has been made worldwide; in particular, the number of people without electricity access 
fell below $1$ billion threshold for the first time in 2017~\cite{IEAweo2018}. 
In order to provide universal electricity for all, decentralized systems led by solar photovoltaic (PV) 
in off-grid and mini-grid systems will be the lowest-cost solution for three-quarters of the additional connections needed \textcolor{red}{Add reference here}; 
specifically grid extension will be the standard in urban areas~\cite{IEAweo2018}.

In order to simulate or evaluate a PV system, there exist various specialized tools, e.g., RETScreen and HOMER~\cite{Pradhan,Swarnkar}%, PVWatts, SAM and Hybrid2 \cite{Pradhan,Swarnkar,NRELDobos,NRELBlair,Mills}
; and even general purpose simulation tools, e.g., MATLAB/Simulink~\cite{Gow1999}. %PSpice, Saber or MATLAB/Simulink package \cite{Gow1999,Benatiallah2017}.
 However, those tools are based on simulation; they have the drawback of an incomplete coverage  since verification of all possible combinations and potential failures of a system is unfeasible~\cite{ClarkeHV18}.
Formal methods based on \textit{model checking} can offer a great potential to obtain a more effective design process of CPSs~\cite{ClarkeHV18}. 
Here, we use program synthesis for synthesizing optimal sizing of stand-alone PV systems using commercial equipment data.
In particular, given a correctness specification $\sigma$, our method uses that as starting point and then incrementally produce a 
sequence of candidate solutions that satisfy $\sigma$, by integrating software model checking techniques.

This paper makes the following original contributions.
Firstly, the use of automated software verification in electrical systems was uncommon in recent prior studies~\cite{abs-1811-09438}, 
and specifically their use in PV sizing is unprecedented. Here, a list of PV components (i.e., PV panels, charge controllers, inverters, and batteries) 
can be fed to the proposed synthesis method together with user requirements and environment constraints, 
and our synthesis algorithm based on software model checking can find the optimal solution in technical and economical terms.
Secondly, we evaluate different state-of-art software verifiers with the goal of obtaining the best performance for synthesizing optimal PV systems.

%-----------------------------------------------------------
\section{BACKGROUND}
\label{sec:AutomatedVerification}
%-----------------------------------------------------------

%-----------------------------------------------------------
\subsection{Program Synthesis}
\label{sec:ProgramSynthesis}
%-----------------------------------------------------------

The basic idea of program synthesis is to automatically construct a program $P$ that satisfies a correctness specification $\sigma$. In particular, program synthesis is automatically performed by engines that use a correctness specification $\sigma$, as starting point, and then incrementally produce a sequence of candidate solutions that satisfy $\sigma$~\cite{Abateetal2017}. As a result, a given candidate program $p$ is iteratively refined, in order to match $\sigma$ more closely. Counter-Example Guided Inductive Synthesis (CEGIS) represents one of the most popular approaches to program synthesis that are currently used in practice for CPS~\cite{Abateetal2017}, whose basic architecture is shown in Figure~\ref{Counter-Example-Guided-Inductive-Synthesis} and has close connections to algorithmic debugging using counterexamples and abstraction refinement~\cite{Alur13}. 

The correctness specification $\sigma$ provided to a program synthesizer is of the form $\exists \vec{F} .  \forall \vec{x}.  \sigma(\vec{x}, \vec{F})$, where $\vec{F}$ ranges over functions, $\vec{x}$ ranges over ground terms, and $\sigma$ is a quantifier-free formula typically supported by SMT solvers. The ground terms are interpreted over some finite domain $\mathcal{D}$, where $\mathcal{D}$ can be encoded using the SMT's bit-vectors part. The phases {\sc Synthesize} and {\sc Verify}, in Figure~\ref{Counter-Example-Guided-Inductive-Synthesis},  interact via a finite set of test vectors {\sc inputs} that is incrementally updated. Given the correctness specification $\sigma$, the {\sc Synthesize} procedure tries to find an existential witness $\vec{F}$ satisfying the specification $\sigma(\vec{x}, \vec{F})$, for all $\vec{x}$ in {\sc inputs} (as opposed to all $\vec{x} \in \mathcal{D}$). If {\sc synthesize} succeeds in finding a witness~$\vec{F}$, the latter is a candidate solution to the full synthesis formula, which is passed to {\sc verify}, in order to check whether it is a proper solution ({\it i.e.}, $\vec{F}$ satisfies the specification $\sigma(\vec{x}, \vec{F})$ for all $\vec{x}\in\mathcal{D}$). If this is the case, then the algorithm terminates; otherwise, additional information is provided to the phase {\sc synthesize}, in the form of a new counterexample that is added to the {\sc inputs} set and the loop iterates again. 
%
\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\columnwidth]{fig2.jpg}
	\caption{CounterExample Guided Inductive Synthesis (CEGIS).}
	\label{Counter-Example-Guided-Inductive-Synthesis}
\end{figure}

One may notice that each iteration of the CEGIS loop adds a new input to the finite set $\text{\sc inputs}$, which is then used for synthesis.  Given that the full set of inputs $\mathcal{D}$ is finite, this means that the refinement loop can only iterate over a finite number of times; however, $\mathcal{D}$ can represent a large number of elements for the finite set $\text{\sc inputs}$. In order to avoid exploring all possible values, machine learning techniques can be used in the phase {\sc synthesize}, with the goal of learning from experience (input-output samples), {\it i.e.}, learning from counterexamples provided by a verification oracle~\cite{Alur13}. In addition to that, a pre-processing stage could also figure as another block in the scheme shown in Fig. \ref{Counter-Example-Guided-Inductive-Synthesis}, between {\sc verify} and {\sc synthesize}, which would process counterexamples and provide larger and refined information to the latter, according to specification $\sigma$ and domain $\mathcal{D}$, in order to speed-up convergence to a final candidate.

Nowadays, program synthesis engines that implement the CEGIS approach~\cite{sketch} can automatically produce solutions for a large variety of specifications, due to the combination of automated testing, genetic algorithms, and SMT-based automated reasoning~\cite{Sharma14}. Here we used software model checking techniques implemented by different tools: CBMC~\cite{Kroening}, CPAChecker~\cite{Beyer2011}, and ESBMC~\cite{esbmc2018}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Sizing Stand-alone Solar PV Systems}
\label{sec:sizing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The modeling of the PV system is based on modular blocks, as illustrated in Fig.\ref{fig:blockdiagram}. %It identifies the PV generator, batteries, charge controller, inverter, and AC load. 
The PV generator, which can be a panel or an array, is a semiconductor device that can convert solar energy into DC electricity. In Fig.\ref{fig:blockdiagram}, there are two variables that depend on the site where the system is deployed and also the weather (i.e., solar irradiance $G$ and temperature $T$). For night hours or rainy days, we hold batteries where power can be stored and used. The use of batteries as a storage form implies the presence of a charge controller~\cite{Hansen}. The PV arrays produce DC and therefore when the PV system contains an AC load, a DC/AC conversion is required. That converter is called of inverter; and the AC load dictates the behavior of AC electrical load from the house that will be fed by the system.
\begin{figure}[h]
\includegraphics[width=0.4\textwidth]{blockdiagramPVS2}
\centering
\caption{Block diagram for a typical stand-alone PV system~\cite{Hansen}.}
\label{fig:blockdiagram} 
\end{figure}
\\

Here the sizing check will be automatically performed by our proposed method; 
this stage will ensure that the system meets the standard project steps related 
to critical period solar energy method~\cite{Pinho} and 
adopting MPPT (Maximum Power Point Tracking) charge controller, 
which is the most common one in practice. 
%
Firstly, we need to correct the energy consumption estimated to the load ($E_{consumption}$), which is carried out by Eq.~\eqref{eq:Ecorrected}, where the efficiency of batteries ($\eta_{b}$), controller ($\eta_{c}$), and the inverter ($\eta_{i}$) are considered~\cite{Pinho} as follows
\begin{equation}
\label{eq:Ecorrected}
\scriptstyle E_{corrected} = \dfrac{\scriptstyle E_{consumption}}{ \scriptstyle \eta_{b} \eta_{c} \eta_{i} }.
\end{equation}

We also need to estimate the energy that can be produced for each panel, called $E_{p}$, in Wh, defined as
%
\begin{equation}
\label{eq:Ep}
\scriptstyle E_{p} = \scriptstyle Solar\_Irradiance \times Panel\_Area \times \eta_{p} \times 1000,
\end{equation}

\noindent where the solar irradiance is expressed in terms of $kWh/m^{2}$ and depends on the site where the PV system will be deployed; 
the PV panel area is given in $m^{2}$ and corresponds to the size of one PV panel, and $\eta_{p}$ represents the PV panel efficiency.
%
The total minimum number of needed solar panels ($N_{TPmin}$) is computed as
%
\begin{equation}
\label{eq:NTPmin}
\scriptstyle N_{TPmin} = \dfrac{\scriptstyle E_{corrected}}{\scriptstyle E_{p}}.
\end{equation}

Particularly, the total number of panels in series ($N_{PSmin}$) and parallel ($N_{PPmin}$) are respectively given by
%
\begin{equation}
\label{eq:NPSmin}
\dfrac{\scriptstyle V_{mppt,min}}{\scriptstyle V_{maxPower,TempMax}} \scriptstyle \leq \scriptstyle N_{PSmin} \leq \dfrac{\scriptstyle V_{mppt,max}}{\scriptstyle V_{maxPower,TempMin}},
\end{equation}

\begin{equation}
\label{eq:NPPmin}
\scriptstyle N_{PPmin} = \dfrac{\scriptstyle P_{total}}{\scriptstyle Number\,Panels\,Series \scriptstyle \times \scriptstyle P_{max,ref}},
\end{equation}

\noindent where $V_{mppt,max}$ is the maximum operation voltage and $V_{mppt,min}$ is the minimum operation voltage of the charge controller; $V_{maxPower,TempMax}$ and $V_{maxPower,TempMin}$ are the maximum power voltage from the PV module considering the maximum and minimum operational temperature, respectively; $P_{total}$ is the total power demanded from the PV system and $P_{max,ref}$ is the power supplied from one PV panel in $Watts$.
%, $ V_{system} $ is the DC voltage of the bus, normally $12$, $24$ or $48$ V.
%
Regarding the batteries, we must first define the total capacity of the battery bank, which can be described as
\begin{equation}
\label{eq:Cbank}
\scriptstyle C_{bank} \scriptstyle = \dfrac{\scriptstyle E_{corrected} \scriptstyle \times \scriptstyle autonomy}{\scriptstyle V_{system} \scriptstyle \times \scriptstyle DOD},
\end{equation}
%
\noindent where the variable $autonomy$ is a design definition; % and normally has a value ranging from $6$ to $48$h; 
$ V_{system} $ is the DC voltage of the bus, and $ DOD $ is the battery deep of discharge (considered of maximum of 25\% here).
%
Secondly, the total (minimum) number of batteries is computed as 
\begin{equation}
\label{eq:Nbtotal}
\scriptstyle N_{B}total = \scriptstyle N_{BS}min \scriptstyle \times \scriptstyle N_{BP}min = \dfrac{\scriptstyle V_{system}}{\scriptstyle V_{bat}} \scriptstyle \times \dfrac{\scriptstyle C_{bank}}{\scriptstyle 1 \,Battery \, Capacity}.
\end{equation}

Regarding the charge controller, it must initially meet the voltage requirement of the PV system, as described by Eq.~\eqref{eq:vcvsystem} to the charge controller voltage: 
\begin{equation}
\label{eq:vcvsystem}
\scriptstyle V_{c} = \scriptstyle V_{system}.
\end{equation}

The short circuit reference information from the manufacturer's solar panel must be corrected to the cell temperature because the field temperature is higher than the nominal or laboratory temperature, and PV system is temperature dependent, as 
%
\begin{equation}
\label{eq:iscamb}
\scriptstyle I_{sc,amb} = \dfrac{\scriptstyle G}{\scriptstyle G_{ref}} \left[ \scriptstyle I_{sc,ref} + \scriptstyle \mu_{I} \scriptstyle \times \scriptstyle (T-25) \right]. 
\end{equation}

The controller must meet the maximum current from the PV array given by Eqs. \eqref{eq:icmin} and \eqref{eq:icicmin}.
\begin{equation}
\label{eq:icmin}
\scriptstyle I_{c,min} = \scriptstyle I_{sc,amb} \times \scriptstyle N_{PP}.
\end{equation}
%
\begin{equation}
\label{eq:icicmin}
\scriptstyle I_{c} \geq \scriptstyle I_{c,min}.
\end{equation}

The sizing project check of the inverter is carried out by means of three equations. Eq.~\eqref{eq:vindc} ensures that the input voltage of the controller meets the system voltage. Eq.~\eqref{eq:voutac} ensures that the output voltage of the controller meets the AC voltage of the load. Finally, Eq.~\eqref{eq:invcheck} ensures that the controller can support the total demand of the load ($Demand$) and the surge power ($P_{surge}$), where $V_{in}DC$ is the nominal input voltage and $V_{out}AC$ is the nominal output voltage of the inverter; $MAX_{AC,ref}$ is the peak power that the inverter can support.
%
\begin{equation}
\label{eq:vindc} 
\scriptstyle V_{in}DC = \scriptstyle V_{system}.
\end{equation}
%
\begin{equation}
\label{eq:voutac} 
\scriptstyle V_{out}AC = \scriptstyle V_{AC}.
\end{equation}
%
\begin{equation}
\label{eq:invcheck} 
\left[ (\scriptstyle Demand \leq \scriptstyle P_{AC,ref}) \, \scriptstyle and \, \scriptstyle (P_{surge} \leq MAX_{AC,ref}) \right].
\end{equation}
% -------------------------------------------------------
\subsection{Optimal sizing of PV systems}
% -------------------------------------------------------

To select an optimal combination of components from a PV system to meet sizing constraints, we need to evaluate \textit{power reliability} and perform \textit{system cost} analysis for the recommended system. An ideal combination for any PV system is made by the best compromise between those two objectives (power reliability and system cost)~\cite{Alsadi2018}. 

Regarding power reliability, this work will rely on the critical period solar energy method~\cite{Pinho} as described in section~\ref{sec:sizing}. 
%the usual is to use loss of load probability (LOLP) or loss of power supply probability (LPSP). Based on the fact that here we are neither considering site characteristics nor the load changes over time, the reliability analysis will be developed only by the critical period method of PV sizing \textcolor{red}{What does it mean? Remember that we have software engineering audience}. 
However, considering the system cost analysis, we usually find related studies done with Net Present Cost (NPC), Levelized Cost of Energy (LCOE), or Life Cycle Cost (LCC). Here, based on the fact that the local of deployment is not specified, our study uses an adapted LCC analysis, where only the deployment cost is considered about the model, i.e., without the operational and maintenance costs~\cite{Alsadi2018}.
%------------------------------------------------------
\section{Synthesizing Optimal Sizing of Stand-alone Solar Photovoltaic Systems}
%Applying Automated Verification to Optimal Sizing of Stand-alone Solar PV Systems}
%------------------------------------------------------
Algorithm~\ref{alg:verification-algorithm} describes the pseudocode used to symthesize stand-alone PV systems using software model checking. 
%
 \begin{algorithm}
 \caption{Synthesis algorithm}
 \begin{algorithmic}[1]
 \begin{scriptsize}
 
 \renewcommand{\algorithmicrequire}{\textbf{Input:}}
 \renewcommand{\algorithmicensure}{\textbf{Output:}}
  \STATE Initialize variables \\
  \STATE Declare list of PV panels data and cost \\
  \STATE Declare list of controllers data and cost \\
  \STATE Declare list of batteries data and cost \\
  \STATE Declare list of inverters data and cost \\
  \STATE Declare the maximum possible cost $MaxCost$  \\
  \STATE Declare power demand, power peak, energy consumption \\
  \STATE Declare battery autonomy, deep of discharge, AC voltage \\
  \FOR {$HintCost=0$ to $MaxCost$}
 	\STATE Declare nondet variable to select PV Panel from list \\
 	\STATE Declare nondet variable to select Controller from list \\
 	\STATE Declare nondet variable to select Battery from list \\
 	\STATE Declare nondet variable to select Inverter from list \\ 	
 	\STATE Calculate $E_{corrected}, \, E_{p} $ \\
	\STATE Calculate $N_{TPmin}, \, N_{PSmin}, N_{PPmin} $ \\
 	\STATE Calculate $C_{bank}$ \\
	\STATE Calculate $N_{BS}min, \, N_{BP}min, \, N_{B}total$ \\
	\STATE Requeriment enforced by \textbf{assume}$(V_{c})$ \\
 	\STATE Calculate $I_{sc,amb}$ \\
 	\STATE Calculate $I_{c,min}$ \\
 	\STATE Requeriment enforced by \textbf{assume}$(I_{c})$ \\
	\STATE Requeriment enforced by \textbf{assume}$(V_{in}DC)$ \\
	\STATE Requeriment enforced by \textbf{assume}$(V_{out}AC)$ \\
	\STATE Requeriment enforced by \textbf{assume}$(Demand)$ \\
	\STATE Requeriment enforced by \textbf{assume}$(P_{surge})$ \\
	\STATE non-det variables hold feasible equipment and cost  \\
	\STATE $F_{obj} \leftarrow  N_{TP}*Panel_{Cost} \, + \, N_{TB}*Battery_{Cost} \, + Controller_{Cost} \, + \, Inverter_{Cost}$ \\
	\STATE Violation check with \textbf{assert}$(F_{obj} > HintCost)$ \\
  \ENDFOR
 \RETURN $(\,)$ 
  \end{scriptsize}
 \end{algorithmic} 
 \label{alg:verification-algorithm}
 \end{algorithm}
 
Our synthesis algorithm starts with the input of manufacturers data and prices of PV panels, batteries, charge controllers and inverters (Lines 2 to 5). After that, we define user requirements, i.e., house requirements and design definitions, from Lines 6 to 8. The \textit{for}-loop started at Line 9 controls the lowest cost to the PV solution. In particular, it starts with cost $0$ and stops only when the algorithm finds a feasible solution in which the cost breaks the assertion stated in Line 28; if that happens, then our algorithm has found an optimal solution, thereby stating that the automatic verification reached a \textit{SAT} (satisfiable) condition. The algorithm uses non-deterministic variables to choose one specific data from a list of PV panels, controllers, batteries and inverters (Lines 10 to 13). That procedure ensures that the automated verification checks all possibilities of items from each equipment, and combine them to assemble a feasible PV solution, which meets the user requirements.

Next, we use Eq.~(\ref{eq:Ecorrected}), Eq.~(\ref{eq:Ep}), Eq.~(\ref{eq:NTPmin}), Eq.~(\ref{eq:NPSmin}), Eq.~(\ref{eq:NPPmin}), Eq.~(\ref{eq:Cbank}), Eq.~(\ref{eq:Nbtotal}), Eq.~(\ref{eq:iscamb}), and Eq.~(\ref{eq:icmin}) to calculate the sizing variables (Lines 14 to 20). The directive \textit{assume} (from Line 21 to 25) ensures the compatibility of the chosen items from the list of equipment: the automatic verification uses only the item (among all the possible ones) that satisfies the statements from Line 14 to 20 in addition to the Line 18. Therefore, our algorithm reaches Line 27 with one feasible solution, and the cost of that solution is calculated in $F_{obj}$.

If our algorithm does not find a feasible solution among the item of equipment that were provided to our synthesis algorithm, then the result is an unsatisfiable (\textit{UNSAT}), i.e., the program finishes and does not find a solution. It indicates that was not possible to combine the itens of each equipment and create a feasible solution. The main challenge for the verification part is to find a feasible solution (technically speaking, regarding the constraints and user requirements), which is the best financial solution at the same time (lowest cost of deployment) from a list of equipment and components that is provided to our synthesis algorithm. \textcolor{red}{An unfeasible solution happens due to the incomplete list of equipment?}
%---------------------------------------------------------------------------
\section{Results and Discussion}
%---------------------------------------------------------------------------
We have performed two case studies to evaluate the proposed approach of optimization as described in Table~\ref{tab1}. Furthermore, three start-of-art verification tools, as described in Section~\ref{sec:AutomatedVerification}: CBMC\footnote{Command-line: \$ cbmc -\phantom{}-unwind 100 filename.c -\phantom{}-trace}, ESBMC\footnote{Command-line: \$ esbmc filename.c -\phantom{}-no-bounds-check -\phantom{}-no-pointer-check -\phantom{}-unwind 100 -\phantom{}-boolector}, %UAutomizer\footnote{Command-line: \$ ./Ultimate -tc config/AutomizerReach.xml -s config/svcomp-Reach-32bit-Automizer\_Default.epf -i filename.c -\phantom{}-traceabstraction.limit.analysis.time 900 -\phantom{}-traceabstraction.stop.after.first.violation.was.found false -\phantom{}-cacsl2boogietranslator.overapproximate.operations.on.floating.types false -\phantom{}- cacsl2boogietranslator.assume.nondeterminstic.values.are.in.range false -\phantom{}-rcfgbuilder.add.additional.assume.for.each.assert true -\phantom{}-rcfgbuilder.simplify.code.blocks true -\phantom{}-rcfgbuilder.size.of.a.code.block LoopFreeBlock}, 
and CPAchecker\footnote{Command-line: \$ scripts/cpa.sh -heap 64000m -config config/bmc-incremental.properties -spec config/specification/sv-comp-reachability.spc filename.c}, were used to compare the approach effectiveness and efficiency. The case studies are related to a stand-alone PV system with the specifications shown in Table~\ref{tab1}. All experiments were conducted on an otherwise idle Intel Xeon CPU E5-4617 (8-cores) with 2.90 GHz and 64 GB of RAM, running Ubuntu 16.04 LTS 64-bits. The experiments were performed with a predefined timeout of 240 minutes.

Only CPAchecker could present the optimal sizing of the two case studies: the result came in 66 minutes and 35 minutes, respectively. %, linking a feasible technical solution with the lowest cost possible, considering the equipment that were inputted to the code. 
CBMC and ESBMC had UNKNOWN result (timeout or out of memory).

%used with the SMT incremental mode\footnote{Command-line: \$ esbmc filename.c -\phantom{}-no-bounds-check -\phantom{}-no-pointer-check -\phantom{}-unwind 100 -\phantom{}-smt-during-symex -\phantom{}-smt-symex-guard -\phantom{}-z3} enabled with the goal of reducing memory usage; we have also used the SMT solver Z3 version 4.7.1~\cite{DeMoura}.
\begin{table}
\caption{Case studies and Results: optimization of PV systems.}\label{tab1}
\begin{scriptsize}
\begin{tabular}{|c|c|c|}
\hline
\hline
 & Case 1 & Case 2\\
\hline
\hline
Tool & \makecell{Demand = 501W \\ Peak = 501W \\ Energy=3900Wh/day \\ Battery autonomy=48h} & \makecell{Demand = 915W \\ Peak = 980W \\ Energy=4880Wh/day \\ Battery autonomy=6h}\\
\hline
\makecell{CBMC 5.11 \\(MiniSat 2.2.1)} & \makecell{UNKNOWN \\(Out of Memory)} & \makecell{UNKNOWN \\(Out of Memory)}\\
\hline
\makecell{ESBMC 6.0.0 \\(Boolector 3.0.1)} & \makecell{UNKNOWN \\(Timeout)} & \makecell{UNKNOWN \\(Timeout)} \\
\hline
%UAutomizer 0.1.24 (Z3 4.8.3) & UNKNOWN & UNKNOWN \\
%\hline
\makecell{CPAchecker 1.8 \\(MathSAT 5.5.3)} & \makecell{SAT (66.18 min) \\ Property violation line 195: \\NTP=4$\times$320W model (2S-2P)\\NBT=4$\times$105Ah model (2S-2P)\\ Controller 15A/100V\\Inverter 700VA, 48V \\ Total Cost=US\$ 2,643.00} & \makecell {SAT (35.41 min) \\ Property violation line 195:  \\NTP=3$\times$320W model (3S)\\NBT=2$\times$105Ah model (2S)\\ Controller 35A/145V \\ Inverter 1,200VA, 48V \\ Total Cost=US\$ 2,125.00}\\
\hline
\hline
\end{tabular}
\end{scriptsize}
\end{table}

More experimentation will be performed with more case studies and to compare the result with some off-the-shelf software that focus on sizing and optimization. Besides, it will be inputted a larger number of components (panels, batteries, controllers and inverters) to the database.
% argument is your BibTeX string definitions and bibliography database(s)
\bibliography{trindadeThesis}{}

\vspace{12pt}

\end{document}
